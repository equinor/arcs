from __future__ import annotations
from collections import defaultdict
from dataclasses import dataclass
from typing import Literal, Any

from chempy.equilibria import Equilibrium, EqSystem
from chempy import Substance
import copy
import networkx as nx
import itertools as it

from tqdm import tqdm
import platform
import psutil

from datetime import datetime
import numpy as np
import pandas as pd

from arcs.model import get_graph, get_reactions


@dataclass
class TraversalResult:
    initfinaldiff: Any
    final_concs: Any
    metadata: dict[str, Any]
    data: dict[str, Any]


def _get_weighted_random_compounds(
    temperature: int,
    pressure: int,
    init_concs: dict[str, float],
    *,
    co2: bool,
    max_compounds: int,
    probability_threshold: float,
    scale_highest: float,
    ceiling: int,
    rng: np.random.Generator,
) -> dict[Any, Any]:
    
    concs = copy.deepcopy(init_concs)
    # CO2 will always be too large as it is the background
    if co2 is False and "CO2" in concs:
        del concs["CO2"]

    positive_concs = [conc for conc in concs.values() if conc > 0]
    num_positive_concs = len(positive_concs)
    if max_compounds > num_positive_concs:
        max_compounds = num_positive_concs

    median_conc = np.median(positive_concs)
    concs_above_ceiling = {
        compound: conc
        for compound, conc in concs.items()
        if conc > (median_conc * (1 + (ceiling / 100)))
    }

    for compound, conc in concs_above_ceiling.items():
        concs[compound] = conc * scale_highest

    compound_probabilities_relative_to_scaled_sum_concs = (
        calculate_compound_probabilities_relative_to_compound_values(concs=concs)
    )
    compound_probabilities_over_threshold = (
        filter_out_compounds_under_probability_threshold(
            probability_threshold=probability_threshold,
            probabilities=compound_probabilities_relative_to_scaled_sum_concs,
        )
    )
    compound_probabilities = (
        calculate_compound_probabilities_relative_to_compound_values(
            compound_probabilities_over_threshold
        )
    )
    compounds = list(compound_probabilities.keys())
    probabilities = list(compound_probabilities.values())

    randomly_selected_weighted_compounds = {
        compound: compound_probabilities[compound]
        for compound in rng.choice(
            compounds, max_compounds, replace=False, p=probabilities
        )
    }
    return randomly_selected_weighted_compounds


def filter_out_compounds_under_probability_threshold(
    probability_threshold: float, probabilities: dict[str, float]
):
    return {
        compound: probability
        for compound, probability in probabilities.items()
        if probability > probability_threshold
    }


def calculate_compound_probabilities_relative_to_compound_values(concs):
    return {compound: conc / sum(concs.values()) for compound, conc in concs.items()}


def _length_multiplier(candidate, *, rank_small_reactions_higher: bool):
    if rank_small_reactions_higher:
        return len(list(candidate))
    else:
        return 1


def _get_weighted_reaction_rankings(
    tempreature: int,
    pressure: int,
    choices: list[str],
    *,
    max_rank: int,
    method: Literal["Bellman-Ford", "Dijkstra"],
    rank_small_reactions_higher: bool,
    graph: nx.MultiDiGraph,
):
    rankings = {}
    if len(choices) > 1:
        possibilities = list(
            nx.shortest_paths.all_shortest_paths(
                graph, list(choices)[0], list(choices)[1], method=method
            )
        )

        for x in possibilities:
            candidates = list(graph[x[1]])
            if len(choices) > 2:
                for c in list(choices)[2:]:
                    if c in candidates:
                        weight = graph.get_edge_data(x[0], x[1])[0][
                            "weight"
                        ] * 10 ** _length_multiplier(
                            graph[x[1]],
                            rank_small_reactions_higher=rank_small_reactions_higher,
                        )
                        rankings[x[1]] = {
                            "candidates": candidates,
                            "weight": weight,
                        }
            else:
                weight = graph.get_edge_data(x[0], x[1])[0][
                    "weight"
                ] * 10 ** _length_multiplier(
                    graph[x[1]],
                    rank_small_reactions_higher=rank_small_reactions_higher,
                )
                rankings[x[1]] = {"candidates": candidates, "weight": weight}
    if rankings:
        sorted_rankings = (
            pd.DataFrame(rankings).sort_values(by="weight", axis=1).to_dict()
        )
        topranks = [
            x for i, x in enumerate(sorted_rankings) if i <= max_rank
        ]  # need to sort first
        rankings = {x: rankings[x] for x in topranks}
        return rankings
    else:
        return None


def _generate_eqsystem(
    index: int, temperature: int, pressure: int, *, reactions: dict[int, Any]
) -> EqSystem | None:
    charged_species = {
        "CO3H": -1,
        "NH4": +1,
        "NH2CO2": -1,
    }
    rs = reactions[index]
    r = rs["e"].reac
    p = rs["e"].prod
    k = rs["k"]
    substances = {}
    for n in list(it.chain(*[list(r) + list(p)])):
        if n in list(charged_species.keys()):
            s = Substance.from_formula(n, **{"charge": charged_species[n]})
            substances[s.name] = s
        else:
            s = Substance.from_formula(
                n, **{"charge": 0}
            )  # ,charge=0) #Â charge buggers up everything have removed for now....
            substances[s.name] = s
    eql = Equilibrium(reac=r, prod=p, param=k)
    try:
        return EqSystem([eql], substances)  # might not just be able to try a return...
    except Exception:
        return None


def _equilibrium_concentrations(
    concs: dict[str, float], eq: EqSystem
) -> tuple[dict[str, float], str]:
    # something is going wrong here...
    fc = defaultdict(lambda: 0.0, concs)
    try:
        x, sol, sane = eq.root(fc)
        assert sol["success"] and sane
        for n, c in enumerate(x):
            fc[eq.substance_names()[n]] = c

        concs = fc
        eq = eq.string()
    except Exception:
        concs = fc
        eq = None
    return (dict(concs), eq)


def _random_walk(
    temperature: int,
    pressure: int,
    concs: dict[str, float],
    *,
    probability_threshold: float,
    path_depth: int,
    max_compounds: int,
    max_rank: int,
    co2: bool,
    scale_highest: float,
    ceiling: int,
    method: Literal["Bellman-Ford", "Dijkstra"],
    rank_small_reactions_higher: bool,
    rng: np.random.Generator,
    reactions: dict[int, Any],
    graph: nx.MultiDiGraph,
):
    final_concs = [concs]
    reactionstats = []

    for _ in range(path_depth):
        fcs = final_concs[-1]
        try:
            choices = _get_weighted_random_compounds(
                temperature,
                pressure,
                fcs,
                max_compounds=max_compounds,
                probability_threshold=probability_threshold,
                co2=co2,
                scale_highest=scale_highest,
                ceiling=ceiling,
                rng=rng,
            )
        except Exception:
            break
        if len(choices) <= 1:
            break
        rankings = _get_weighted_reaction_rankings(
            temperature,
            pressure,
            choices,
            max_rank=max_rank,
            method=method,
            rank_small_reactions_higher=rank_small_reactions_higher,
            graph=graph,
        )
        if not rankings:
            break
        weights = {k: 1 / rankings[k]["weight"] for k in rankings}
        probabilities = {k: v / sum(weights.values()) for k, v in weights.items()}
        chosen_reaction = rng.choice(
            [
                rng.choice(
                    list(probabilities.keys()),
                    len(probabilities),
                    p=list(probabilities.values()),
                )
            ][0]
        )

        eqsyst = _generate_eqsystem(
            chosen_reaction, temperature, pressure, reactions=reactions
        )
        # if reaction was previous reaction then break
        path_available = [r for r in reactionstats if r is not None]
        if path_available:
            if (
                eqsyst.string() == path_available[-1]
                and eqsyst.string() == path_available[-1]
            ):
                break  # extra break

        a, b = _equilibrium_concentrations(fcs, eqsyst)
        final_concs.append(a)
        reactionstats.append(b)

    return {
        "data": final_concs[-1],
        "equation_statistics": [r for r in reactionstats if r is not None],
        "path_length": len([r for r in reactionstats if r is not None]),
    }


def _sample(
    temperature: int,
    pressure: int,
    concs: dict[str, float],
    *,
    co2: bool,
    max_compounds: int,
    probability_threshold: float,
    max_rank: int,
    sample_length: int,
    path_depth: int,
    ceiling: int,
    scale_highest: float,
    rank_small_reactions_higher: bool,
    method: Literal["Bellman-Ford"],
    rng: np.random.Generator,
    reactions: dict[int, Any],
    graph: nx.MultiDiGraph,
) -> dict[int, Any]:
    result_dict = {0: {"data": concs, "equation_statistics": [], "path_length": None}}
    with tqdm(
        total=sample_length,
        bar_format="progress: {desc:<10}|{bar:50}|",
        ascii=" >=",
        position=0,
        leave=False,
    ) as pbar:
        for sample in range(sample_length):
            result_dict[sample + 1] = _random_walk(
                temperature,
                pressure,
                concs,
                probability_threshold=probability_threshold,
                path_depth=path_depth,
                max_compounds=max_compounds,
                max_rank=max_rank,
                co2=co2,
                scale_highest=scale_highest,
                ceiling=ceiling,
                method=method,
                rank_small_reactions_higher=rank_small_reactions_higher,
                rng=rng,
                reactions=reactions,
                graph=graph,
            )
            pbar.update(1)
    return result_dict


def traverse(
    temperature: int,
    pressure: int,
    concs: dict[str, float],
    *,
    co2: bool = False,
    max_compounds: int = 5,
    probability_threshold: float = 0.05,
    max_rank: int = 5,
    sample_length: int = 1000,
    path_depth: int = 20,
    ceiling: int = 2000,
    scale_highest: float = 0.1,
    rank_small_reactions_higher: bool = True,
    method: Literal["Bellman-Ford", "Dijkstra"] = "Bellman-Ford",
    rng: np.random.Generator | None = None,
    reactions: dict[int, Any] | None = None,
    graph: nx.MultiDiGraph | None = None,
) -> TraversalResult:
    if rng is None:
        rng = np.random.default_rng()
    if graph is None:
        graph = get_graph(temperature, pressure)
    if reactions is None:
        reactions = get_reactions(temperature, pressure)

    concstring = pd.Series({k: v for k, v in concs.items() if v > 0}) / 1e-6
    if "CO2" in concstring:
        del concstring["CO2"]

    path_lengths = []
    data = _sample(
        temperature,
        pressure,
        concs,
        co2=co2,
        max_compounds=max_compounds,
        probability_threshold=probability_threshold,
        max_rank=max_rank,
        sample_length=sample_length,
        path_depth=path_depth,
        ceiling=ceiling,
        scale_highest=scale_highest,
        rank_small_reactions_higher=rank_small_reactions_higher,
        method=method,
        rng=rng,
        reactions=reactions,
        graph=graph,
    )

    reformatted = [{x: v for x, v in data[i]["data"].items()} for i in data]
    mean = (
        pd.Series(
            {k: v for k, v in pd.DataFrame(reformatted).mean().items() if v > 0.5e-6}
        )
        / 1e-6
    )

    final_concs = mean.to_dict()
    diff_concs = pd.Series(mean.to_dict()) - pd.Series(
        {k: v / 1e-6 for k, v in concs.items()}
    )
    ift = pd.DataFrame(
        [
            {k: v / 1e-6 for k, v in concs.items() if v > 0},
            mean.to_dict(),
            diff_concs.to_dict(),
        ],
        index=["initial", "final", "change"],
    ).T
    initfinaldiff = ift.dropna(how="all").fillna(0.0).to_dict()
    avgpathlength = np.median(
        [data[i]["path_length"] for i in data if data[i]["path_length"] is not None]
    )

    path_lengths.append(avgpathlength)

    metadata = {
        "arcs_version": "1.4.0",
        "avg_path_length": np.mean(path_lengths),
        "co2": co2,
        "max_compounds": max_compounds,
        "probability_threshold": probability_threshold,
        "shortest_path_method": method,
        "max_rank": max_rank,
        "sample_length": sample_length,
        "path_depth": path_depth,
        "ceiling": ceiling,
        "scale_highest": scale_highest,
        "rank_small_reactions_higher": rank_small_reactions_higher,
        "platform": platform.platform(),
        "python_version": platform.python_version(),
        "processor": platform.processor(),
        "available_cores": psutil.cpu_count(),
        "available_memory": str(int(psutil.virtual_memory()[0] / 1000 / 1000 / 1000))
        + "Gb",
        "date": str(datetime.now()),
    }

    return TraversalResult(
        initfinaldiff=initfinaldiff,
        final_concs=final_concs,
        data=data,
        metadata=metadata,
    )
